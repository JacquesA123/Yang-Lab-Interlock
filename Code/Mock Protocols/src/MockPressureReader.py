# Pressure Reader Programimport csvimport datetimeimport numpy as npimport threading #allows multiple parts of program to run concurrentlyimport tkinter as tk #Graphical User Interfacefrom collections import deque  # Import deque for efficient data storagefrom tkinter import ttk  # Import ttk for Treeview widgetimport matplotlib.pyplot as plt  # Import Matplotlib for plottingfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg  # Tkinter canvas for Matplotlib#import mock serial portfrom MockPfiefferProtocol import Serial, PPT100#import pfeiffer_vacuum_protocol as pvp #This is the protocol directly from the source codeimport PfiefferVacuumProtocol as pvp #This is the edited protocol#The following example will read out pressure from a mock gauge of your choice. The pressure returned will be in bar.# Create a mock Pfeiffer gauge of your choicemock_gauge = PPT100()  # Simulating a Pfeiffer vacuum gauge (PPT100)# Create a mock serial connections = Serial(connected_device=mock_gauge, port="COM1", timeout=1)# Create a deque to store the pressure readings for the last 10 seconds (10 items)pressure_data = deque(maxlen=10)'''# Read the pressure from the simulated gauge and print it (one time)p = pvp.read_pressure(s, 1)random_number = np.random.random()*0.1 - 0.05random_pressure = p + random_numberprint(random_number)print("Pressure: {:.3f} bar".format(random_pressure))'''# Function to generate random noise for pressure readingsdef generate_noise():    return np.random.random() * 0.1 - 0.05  # Noise between -0.05 and 0.05# Function to read pressure and update the labeldef get_pressure():    try:        p = pvp.read_pressure(s, 1)  # Get pressure from the gauge                #Denote pressure 1 value        random_pressure1 = p + generate_noise()  # Simulated pressure value with noise        #Denote pressure 2 value        random_pressure2 = p + generate_noise()  # Simulated pressure value with noise        # Add the new pressure readings to the deque (stores last 10 seconds) #Deque is a list where you can add or pop to the front and back        timestamp = datetime.datetime.now().strftime("%H:%M:%S") #generates the current timestamp        pressure_data.append((timestamp, random_pressure1, random_pressure2))        pressure_label1.config(text=f"Pressure 1: {random_pressure1:.3f} bar")  # Update GUI text for first pressure reading        pressure_label2.config(text=f"Pressure 2: {random_pressure2:.3f} bar")  # Update GUI text for second pressure reading        # Update the data window if open        if "pressure_window" in globals() and pressure_window.winfo_exists():            update_pressure_table()        # Update the graph if open        if "fig" in globals():            update_graph()        # Display the last 10 seconds of data in the window        data_text = "\n".join([f"{pressure_data[i][0]}: {pressure_data[i][1]:.3f} bar, {pressure_data[i][2]:.3f} bar"                        for i in range(len(pressure_data))])        pressure_data_label.config(text=f"Last 60 Seconds of Pressure Data:\n{data_text}")    except Exception as e:        print(f"Error reading pressure: {e}")    # Schedule the next update (this avoids blocking the main GUI thread)    root.after(1000, get_pressure) #schedules the get_pressure function to be called again after 1000 ms (1 seconds)# Function to display the last 60 seconds of pressure data in a new windowdef show_pressure_data():    global pressure_window, tree  #tree is the data table, pressure_window is the window #global variables are variables in a program that can be accessed from any part of that program    # Check if the window is already open    if "pressure_window" in globals() and pressure_window.winfo_exists():        return  # Do nothing if the window is already open    #Create a new window to display pressure    pressure_window = tk.Toplevel(root)    pressure_window.title("Last 10 Seconds of Pressure Data")    # Create a Treeview widget to display the pressure data as a table    tree = ttk.Treeview(pressure_window, columns=("Time", "Pressure 1 (bar)", "Pressure 2 (bar)")) #Time, Pressure1,, and Pressure 2 are the three columns    # Define column headings    tree.heading("Time", text="Time")    tree.heading("Pressure 1 (bar)", text="Pressure 1 (bar)")    tree.heading("Pressure 2 (bar)", text="Pressure 2 (bar)")    # Add the Treeview widget to the window    tree.pack(padx=20, pady=20)    # Button that shows the graph when clicked    graph_button = tk.Button(pressure_window, text="Pressure vs Time Graph (Last 60 seconds)", font=("Helvetica", 16), command=lambda: show_graph(pressure_window))    graph_button.pack(pady=20)    #Autoupdate the table using the update_pressure_table function    update_pressure_table()def update_pressure_table():    """Updates the pressure data table dynamically."""    if "tree" not in globals():        return  #Check if the tree table exists and do nothing if it does not exist    #Clear the existing table entries so they can be replaced by new ones    for item in tree.get_children():        tree.delete(item)    #Insert updated pressure data after clearing it previously    for timestamp, pressure1, pressure2 in pressure_data:        tree.insert("", "end", values=(timestamp, f"{pressure1:.3f}", f"{pressure2:.3f}")) #format pressure value to three decimal places    #Schedule the next update    if "pressure_window" in globals() and pressure_window.winfo_exists(): #Check if window variable still exists and check if window is still open        pressure_window.after(1000, update_pressure_table)  #Schedules to update pressure_window every second# Function to show the pressure graph over timedef show_graph(pressure_window):    global fig, ax, canvas  # Store references to update later (figure, axis, canvas)    #Create a matplotlib figure for the plot    fig, ax = plt.subplots(figsize=(6, 4))        #Create a button to save a snapshot of the current graph image and its corresponding data in a CSV file    #Create a frame for the button to save a snapshot of the graph data in a CSV file    button_frame = tk.Frame(pressure_window)    button_frame.pack(side=tk.TOP, pady=10)  # Places the frame at the top of the graph    #Button to save snapshot graph data    save_data_button = tk.Button(button_frame, text="Save Data Snapshot", font=("Helvetica", 12), command=save_graph_data)    save_data_button.pack()  # Packs the button inside the frame    #Create canvas to embed plot inside Tkinter (positioned below the button)    canvas = FigureCanvasTkAgg(fig, master=pressure_window)    canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)  # Expands within window    # Start updating the graph    update_graph()    # Label to indicate auto-save is enabled    auto_save_label = tk.Label(button_frame, text="Auto-saving data every 10 seconds", font=("Helvetica", 10), fg="green")    auto_save_label.pack(pady=5)    # Auto-save the graph every X seconds    autosave_graph_data()#Function which updates the graph every one seconddef update_graph():    """Updates the pressure graph dynamically."""    if "ax" not in globals(): #Check if the graph axis exists. If not, then do not update the graph        return    #Clear previous graph    ax.clear()    # Extract time stamps and pressure data    timestamps = [data[0] for data in pressure_data]    pressure1_values = [data[1] for data in pressure_data]    pressure2_values = [data[2] for data in pressure_data]    # Plot new data    ax.plot(timestamps, pressure1_values, label="Pressure 1", color='blue')    ax.plot(timestamps, pressure2_values, label="Pressure 2", color='red')    # Set graph labels and limits    ax.set_xlabel("Time (s)")    ax.set_ylabel("Pressure (bar)")    ax.set_title("Pressure vs Time (Last 60 seconds)")    ax.legend()    ax.set_ylim(0.750, 1.250)  # Keep y-axis fixed        # **Reduce overcrowding of x-axis labels**    if len(timestamps) > 1:  # Only adjust if we have more than 10 data points        step = max(1, len(timestamps) // 6)  # Show ~6 evenly spaced labels        ax.set_xticks(timestamps[::step])        ax.set_xticklabels(timestamps[::step], rotation=45, ha="right")  # Rotate labels for better visibility        plt.subplots_adjust(bottom=0.25)    # Redraw the canvas with new data    canvas.draw()    # Schedule next update    if "fig" in globals():        root.after(1000, update_graph)  # Update every second# Function to save plot data as a CSV file and plot image as png filedef save_graph_data():    if not pressure_data:        print("No data available to save.")        return    # Generate a timestamped filename    timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")    data_filename = f"pressure_data_snapshot_{timestamp}.csv"    plot_filename = f"pressure_data_snapshot_{timestamp}.png"    # Save plot data as CSV    with open(data_filename, mode='w', newline='') as file:        writer = csv.writer(file)        writer.writerow(["Time", "Pressure 1 (bar)", "Pressure 2 (bar)"])        for time, pressure1, pressure2 in pressure_data:            writer.writerow([time, pressure1, pressure2])    print(f"Graph data saved as {data_filename}")    #Save plot image as PNG    if "fig" in globals():        fig.savefig(plot_filename, dpi=300)        print(f"Graph image saved as {plot_filename}")# Function to autosave the graph .csv and .png data every X secondsdef autosave_graph_data():    if pressure_data:        save_graph_data    # Schedule this function to run again X milliseconds later    root.after(10000, autosave_graph_data)# Setup the GUIroot = tk.Tk() #Creates a root window to display the pressureroot.title("Live Pressure Reader") #titles the window# Label to display the first pressure with a borderpressure_label1 = tk.Label(    root,     text="Pressure: 0.000 bar",     font=("Helvetica", 40),     relief="solid",  # Adds a solid border around the label    borderwidth=10,  # Thickness of the border    padx=100,  # Horizontal size of the box    pady=50  # Vertical size of the box)pressure_label1.pack(pady=100, padx=100) #places the presure label in the window and controls how much whitespace is above and below it# Label to display the second pressure with a borderpressure_label2 = tk.Label(    root,     text="Pressure: 0.000 bar",     font=("Helvetica", 40),     relief="solid",      borderwidth=10,      padx=100,      pady=50  )pressure_label2.pack(pady=10, padx=10)# Label to display the last 10 seconds of pressure datapressure_data_label = tk.Label(    root,     text="Last 60 Seconds of Pressure Data:",     font=("Helvetica", 14),     relief="solid",     borderwidth=5,     padx=20,     pady=20)# Button to open the "Pressure Data" windowpressure_data_button = tk.Button(root, text="Pressure Data (Last 60 seconds)", font=("Helvetica", 16), command=show_pressure_data)pressure_data_button.pack(pady=20)# Create and start a background thread to read pressure (allows the window to update values as the program is running)thread = threading.Thread(target=get_pressure, daemon=True)thread.start()# Start the looproot.mainloop()